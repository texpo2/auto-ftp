#cloud-config
# KISA/CSAP 보안 가이드라인 준수 FTP 서버 설정 (최적화 및 오류 수정 버전)

# 부트 명령 (가장 먼저 실행) - DNS 설정
bootcmd:
  - echo "nameserver 168.63.129.16" > /etc/resolv.conf
  - echo "nameserver 8.8.8.8" >> /etc/resolv.conf
  - echo "nameserver 8.8.4.4" >> /etc/resolv.conf
  - echo "options timeout:2 attempts:3" >> /etc/resolv.conf

# 패키지 업데이트 설정
package_update: true
package_upgrade: false
package_reboot_if_required: false

# 저장소 설정 (Rocky Linux 9 호환)
yum_repos:
  docker-ce-stable:
    name: Docker CE Stable - $basearch
    baseurl: https://download.docker.com/linux/rhel/9/$basearch/stable
    enabled: true
    gpgcheck: true
    gpgkey: https://download.docker.com/linux/rhel/gpg

# 필수 패키지 설치
packages:
  - epel-release
  - firewalld
  - curl
  - wget
  - git
  - openssl
  - dnf-plugins-core
  - container-selinux

# 파일 생성
write_files:
  # DNS 설정 고정
  - path: /etc/NetworkManager/conf.d/dns.conf
    content: |
      [main]
      dns=none

  - path: /etc/systemd/resolved.conf
    content: |
      [Resolve]
      DNS=168.63.129.16 8.8.8.8 8.8.4.4
      FallbackDNS=1.1.1.1
      DNSStubListener=no

  # Docker 설치 스크립트 (재시도 로직 강화)
  - path: /opt/install_docker.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -e

      LOG="/var/log/docker-install.log"
      exec > >(tee -a $LOG) 2>&1

      echo "$(date): Docker 설치 시작"

      # 네트워크 연결 확인 (더 긴 대기시간)
      for i in {1..10}; do
        if curl -s --connect-timeout 10 https://www.google.com > /dev/null; then
          echo "$(date): 네트워크 연결 확인 완료"
          break
        fi
        echo "$(date): 네트워크 연결 재시도 $i/10"
        sleep 15
      done

      # 기존 Docker 정리 (있다면)
      dnf remove -y docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine || true

      # Docker 저장소 추가 (Rocky Linux 9 호환)
      for i in {1..3}; do
        if dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo; then
          echo "$(date): Docker 저장소 추가 성공"
          break
        fi
        echo "$(date): Docker 저장소 추가 재시도 $i/3"
        sleep 10
      done

      # Docker 설치
      dnf install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

      # Docker 서비스 시작
      systemctl enable docker
      systemctl start docker

      # Docker 상태 확인 및 대기
      for i in {1..10}; do
        if docker info >/dev/null 2>&1; then
          echo "$(date): Docker 서비스 정상 동작 확인"
          break
        fi
        echo "$(date): Docker 서비스 시작 대기 중... $i/10"
        sleep 10
      done

      docker --version
      echo "$(date): Docker 설치 완료"

  # 공인 IP 조회 함수 (오류 수정)
  - path: /opt/get_public_ip.sh
    permissions: "0755"
    content: |
      #!/bin/bash

      LOG="/var/log/ftp-setup.log"

      get_public_ip() {
        local ip=""
        
        # 방법 1: Azure 메타데이터 서비스 (최신 API)
        echo "$(date): Azure 메타데이터로 공인 IP 조회 시도" >> $LOG
        ip=$(curl -s -H Metadata:true --connect-timeout 10 "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2021-12-13&format=text" 2>/dev/null | tr -d '\n' | tr -d ' ')
        if [[ "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
          echo "$ip"
          return 0
        fi
        
        # 방법 2: Azure 메타데이터 서비스 (구 API)
        echo "$(date): Azure 메타데이터 구 API로 재시도" >> $LOG
        ip=$(curl -s -H Metadata:true --connect-timeout 10 "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-08-01" 2>/dev/null | jq -r '.' 2>/dev/null | tr -d '\n' | tr -d ' ')
        if [[ "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
          echo "$ip"
          return 0
        fi
        
        # 방법 3: 외부 서비스들
        echo "$(date): 외부 서비스로 공인 IP 조회" >> $LOG
        for service in "ifconfig.me" "ipinfo.io/ip" "icanhazip.com"; do
          ip=$(curl -s --connect-timeout 10 "$service" 2>/dev/null | tr -d '\n' | tr -d ' ')
          if [[ "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "$ip"
            return 0
          fi
          sleep 2
        done
        
        # 방법 4: 기본값 (로컬에서만 접근 가능)
        echo "$(date): 공인 IP 조회 실패, 로컬 IP 사용" >> $LOG
        echo "127.0.0.1"
        return 1
      }

      # 공인 IP 조회 실행
      get_public_ip

  # KISA/CSAP 보안 체크리스트 검증 스크립트
  - path: /home/azureuser/safe_checker.sh
    permissions: "0755"
    content: |
      #!/bin/bash

      # KISA/CSAP 기술적취약점평가분석상세가이드 준수 검증 스크립트
      # Unix/Linux 및 Cloud 보안 체크리스트 검증

      # 안전한 실행을 위해 set -e 제거하고 개별적으로 오류 처리

      LOG_FILE="/var/log/kisa-csap-check.log"
      REPORT_FILE="/var/log/kisa-csap-report.txt"

      # 색상 정의
      RED='\033[0;31m'
      GREEN='\033[0;32m'
      YELLOW='\033[1;33m'
      BLUE='\033[0;34m'
      NC='\033[0m' # No Color

      # 로그 함수
      log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE" 2>/dev/null || echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
      }

      # 안전한 명령 실행 함수
      safe_exec() {
          local cmd="$1"
          local desc="$2"
          if eval "$cmd" >/dev/null 2>&1; then
              return 0
          else
              log "명령 실행 실패: $desc ($cmd)"
              return 1
          fi
      }

      print_header() {
          echo -e "\n${BLUE}=== $1 ===${NC}"
          log "=== $1 ==="
      }

      check_pass() {
          echo -e "${GREEN}[PASS]${NC} $1"
          log "[PASS] $1"
      }

      check_fail() {
          echo -e "${RED}[FAIL]${NC} $1"
          log "[FAIL] $1"
      }

      check_warn() {
          echo -e "${YELLOW}[WARN]${NC} $1"
          log "[WARN] $1"
      }

      # 초기화 및 사전 검사
      mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
      mkdir -p "$(dirname "$REPORT_FILE")" 2>/dev/null || true

      echo "KISA/CSAP 기술적취약점평가 체크리스트 검증 리포트" > "$REPORT_FILE" 2>/dev/null || {
          REPORT_FILE="/tmp/kisa-csap-report.txt"
          echo "KISA/CSAP 기술적취약점평가 체크리스트 검증 리포트" > "$REPORT_FILE"
      }
      echo "생성일시: $(date)" >> "$REPORT_FILE"
      echo "======================================================" >> "$REPORT_FILE"

      print_header "KISA/CSAP 기술적취약점평가 체크리스트 검증 시작"

      # 기본 권한 확인
      if [ "$EUID" -ne 0 ]; then
          echo -e "${YELLOW}[INFO]${NC} 일부 검사는 root 권한이 필요합니다. sudo로 실행하시면 더 정확한 결과를 얻을 수 있습니다."
      fi

      # Docker 서비스 상태 사전 확인
      print_header "사전 환경 확인"
      if command -v docker >/dev/null 2>&1; then
          if systemctl is-active docker >/dev/null 2>&1; then
              check_pass "Docker 서비스 활성화"
              DOCKER_AVAILABLE=true
          else
              check_warn "Docker 서비스 비활성화 상태"
              DOCKER_AVAILABLE=false
          fi
      else
          check_warn "Docker 명령어 사용 불가"
          DOCKER_AVAILABLE=false
      fi

      # ============================================================================
      # 1. Unix/Linux 보안 체크리스트
      # ============================================================================

      print_header "1. Unix/Linux 보안 체크리스트"

      # 1.1 계정 관리
      print_header "1.1 계정 관리"

      # 불필요한 계정 확인
      echo "FTP 설정 파일 확인 중..."
      FTP_CONFIG="/opt/ftp/config/vsftpd.conf"
      if [ -f "$FTP_CONFIG" ]; then
          if grep -q "anonymous_enable=NO" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "익명 FTP 접근 차단"
          else
              check_fail "익명 FTP 접근이 허용되어 있음"
          fi
      else
          check_warn "FTP 설정 파일이 아직 생성되지 않음 ($FTP_CONFIG)"
      fi

      # root 계정 원격 접속 확인
      if grep -q "disable_root: false" /etc/cloud/cloud.cfg.d/* 2>/dev/null; then
          check_warn "root 계정 원격 접속이 허용됨 (운영환경에서는 비활성화 권장)"
      else
          check_pass "root 계정 원격 접속 제한"
      fi

      # 패스워드 정책 확인
      echo "패스워드 정책 확인 중..."
      if [ "$DOCKER_AVAILABLE" = true ]; then
          if docker exec secure-ftp-server env 2>/dev/null | grep -q "FTP_PASS=.*[A-Z].*[0-9].*[!@#]"; then
              check_pass "FTP 계정 강력한 패스워드 사용"
          else
              # 컨테이너가 실행 중이 아닐 수도 있음
              if docker ps --format "{{.Names}}" 2>/dev/null | grep -q "secure-ftp-server"; then
                  check_warn "FTP 계정 패스워드 복잡성 확인 필요"
              else
                  check_warn "FTP 컨테이너가 아직 실행되지 않음"
              fi
          fi
      else
          check_warn "Docker 사용 불가로 FTP 패스워드 정책 확인 불가"
      fi

      # 1.2 접근 제어
      print_header "1.2 접근 제어"

      # 사용자 권한 제한 확인
      if [ -f "$FTP_CONFIG" ]; then
          if grep -q "userlist_enable=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "FTP 사용자 화이트리스트 설정"
          else
              check_fail "FTP 사용자 접근 제어 미설정"
          fi
          
          # chroot 설정 확인
          if grep -q "chroot_local_user=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "chroot jail 설정으로 디렉토리 접근 제한"
          else
              check_fail "chroot 설정 미적용"
          fi
      else
          check_warn "FTP 설정 파일 부재로 접근 제어 설정 확인 불가"
      fi

      # 파일 권한 확인
      echo "중요 파일 권한 확인 중..."
      if [ -f "/opt/ftp/certs/vsftpd.key" ]; then
          key_perm=$(stat -c "%a" /opt/ftp/certs/vsftpd.key 2>/dev/null || echo "000")
          if [ "$key_perm" = "600" ]; then
              check_pass "SSL 개인키 파일 권한 적절 (600)"
          else
              check_fail "SSL 개인키 파일 권한 부적절 ($key_perm)"
          fi
      fi

      # 1.3 로깅 및 감사
      print_header "1.3 로깅 및 감사"

      # FTP 로깅 확인
      if [ -f "$FTP_CONFIG" ]; then
          if grep -q "xferlog_enable=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "FTP 파일 전송 로깅 활성화"
          else
              check_fail "FTP 파일 전송 로깅 비활성화"
          fi

          if grep -q "log_ftp_protocol=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "FTP 프로토콜 로깅 활성화"
          else
              check_fail "FTP 프로토콜 로깅 비활성화"
          fi
      else
          check_warn "FTP 설정 파일 부재로 로깅 설정 확인 불가"
      fi

      # 시스템 로그 확인
      if systemctl is-active rsyslog >/dev/null 2>&1 || systemctl is-active systemd-journald >/dev/null 2>&1; then
          check_pass "시스템 로깅 서비스 활성화"
      else
          check_warn "시스템 로깅 서비스 상태 확인 필요"
      fi

      # 1.4 네트워크 보안
      print_header "1.4 네트워크 보안"

      # 방화벽 설정 확인
      if systemctl is-active firewalld >/dev/null 2>&1; then
          check_pass "방화벽 서비스 활성화"
          
          # 필요한 포트만 열려있는지 확인
          open_ports=$(firewall-cmd --list-ports 2>/dev/null || echo "")
          if echo "$open_ports" | grep -q "21/tcp.*30000-30010/tcp"; then
              check_pass "필요한 FTP 포트만 개방 (21, 30000-30010)"
          else
              check_warn "방화벽 포트 설정 확인 필요: $open_ports"
          fi
      else
          check_fail "방화벽 서비스 비활성화"
      fi

      # 불필요한 서비스 확인
      echo "불필요한 서비스 확인 중..."
      unnecessary_services=("telnet" "rsh" "rlogin" "finger" "tftp")
      for service in "${unnecessary_services[@]}"; do
          if systemctl is-enabled "$service" >/dev/null 2>&1; then
              check_fail "불필요한 서비스 활성화됨: $service"
          else
              check_pass "불필요한 서비스 비활성화: $service"
          fi
      done

      # 1.5 암호화 설정
      print_header "1.5 암호화 설정"

      # SSL/TLS 설정 확인
      if [ -f "$FTP_CONFIG" ]; then
          if grep -q "ssl_enable=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "FTP SSL/TLS 암호화 활성화"
          else
              check_fail "FTP SSL/TLS 암호화 비활성화"
          fi

          if grep -q "force_local_data_ssl=YES" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "데이터 전송 SSL 강제 활성화"
          else
              check_fail "데이터 전송 SSL 강제 비활성화"
          fi

          if grep -q "ssl_sslv2=NO" "$FTP_CONFIG" 2>/dev/null && grep -q "ssl_sslv3=NO" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "취약한 SSL 버전 (SSLv2/v3) 비활성화"
          else
              check_warn "취약한 SSL 버전 설정 확인 필요"
          fi
      else
          check_warn "FTP 설정 파일 부재로 SSL/TLS 설정 확인 불가"
      fi

      # ============================================================================
      # 2. Cloud 보안 체크리스트
      # ============================================================================

      print_header "2. Cloud 보안 체크리스트"

      # 2.1 컨테이너 보안
      print_header "2.1 컨테이너 보안"

      # Docker 보안 설정 확인
      if [ "$DOCKER_AVAILABLE" = true ]; then
          if docker ps --format "table {{.Names}}\t{{.Status}}" 2>/dev/null | grep -q "secure-ftp-server.*Up"; then
              check_pass "FTP 컨테이너 정상 실행 중"
              
              # 권한 제한 확인
              caps=$(docker inspect secure-ftp-server 2>/dev/null | grep -A 10 "CapAdd" | grep -o '"[A-Z_]*"' | tr -d '"' | tr '\n' ' ' || echo "")
              if echo "$caps" | grep -q "CHOWN.*SETUID.*SETGID"; then
                  check_pass "컨테이너 최소 권한 설정 (CHOWN, SETUID, SETGID 등 허용)"
              else
                  check_warn "컨테이너 권한 설정 확인 필요: $caps"
              fi
          else
              check_warn "FTP 컨테이너가 실행되지 않음 (아직 설정 중일 수 있음)"
          fi
      else
          check_warn "Docker 사용 불가로 컨테이너 보안 설정 확인 불가"
      fi

      # 2.2 데이터 보호
      print_header "2.2 데이터 보호"

      # SSL 인증서 확인
      if [ -f "/opt/ftp/certs/vsftpd.pem" ] && [ -f "/opt/ftp/certs/vsftpd.key" ]; then
          check_pass "SSL 인증서 파일 존재"
          
          # 인증서 유효성 확인
          if openssl x509 -in /opt/ftp/certs/vsftpd.pem -noout -checkend 86400 >/dev/null 2>&1; then
              check_pass "SSL 인증서 유효기간 내"
          else
              check_warn "SSL 인증서 만료 임박 또는 만료됨"
          fi
      else
          check_fail "SSL 인증서 파일 누락"
      fi

      # 데이터 디렉토리 권한 확인
      if [ -d "/opt/ftp/data" ]; then
          data_perm=$(stat -c "%a" /opt/ftp/data 2>/dev/null || echo "000")
          if [ "$data_perm" = "755" ] || [ "$data_perm" = "750" ]; then
              check_pass "데이터 디렉토리 권한 적절 ($data_perm)"
          else
              check_warn "데이터 디렉토리 권한 확인 필요 ($data_perm)"
          fi
      fi

      # 2.3 네트워크 분리 및 접근 제어
      print_header "2.3 네트워크 분리 및 접근 제어"

      # 패시브 모드 포트 제한 확인
      if [ -f "$FTP_CONFIG" ]; then
          if grep -q "pasv_min_port=30000" "$FTP_CONFIG" 2>/dev/null && grep -q "pasv_max_port=30010" "$FTP_CONFIG" 2>/dev/null; then
              check_pass "패시브 모드 포트 범위 제한 (30000-30010)"
          else
              check_warn "패시브 모드 포트 범위 설정 확인 필요"
          fi
      else
          check_warn "FTP 설정 파일 부재로 패시브 모드 설정 확인 불가"
      fi

      # 2.4 시스템 및 정보의 무결성
      print_header "2.4 시스템 및 정보의 무결성"

      # 패키지 무결성 확인
      if command -v rpm >/dev/null 2>&1; then
          echo "시스템 패키지 무결성 확인 중..."
          if rpm -Va 2>/dev/null | head -10 | grep -q "^..5"; then
              check_warn "일부 시스템 파일이 변경됨 (정상적인 설정 변경일 수 있음)"
          else
              check_pass "주요 시스템 파일 무결성 양호"
          fi
      fi

      # Docker 이미지 무결성 확인
      if [ "$DOCKER_AVAILABLE" = true ]; then
          if docker image inspect fauria/vsftpd:latest >/dev/null 2>&1; then
              check_pass "FTP Docker 이미지 존재"
          else
              check_warn "FTP Docker 이미지 누락 (아직 다운로드되지 않음)"
          fi
      else
          check_warn "Docker 사용 불가로 이미지 확인 불가"
      fi

      # 2.5 로깅 및 모니터링
      print_header "2.5 로깅 및 모니터링"

      # 로그 파일 존재 확인
      log_files=(
          "/var/log/docker-install.log"
          "/var/log/ftp-setup.log"
          "/opt/ftp/logs"
      )

      for log_file in "${log_files[@]}"; do
          if [ -e "$log_file" ]; then
              check_pass "로그 파일/디렉토리 존재: $log_file"
          else
              check_warn "로그 파일/디렉토리 누락: $log_file"
          fi
      done

      # Docker 로그 드라이버 확인
      if [ "$DOCKER_AVAILABLE" = true ]; then
          if docker info 2>/dev/null | grep -q "Logging Driver"; then
              check_pass "Docker 로깅 드라이버 설정됨"
          else
              check_warn "Docker 로깅 설정 확인 필요"
          fi
      fi

      # ============================================================================
      # 3. 추가 보안 권장사항
      # ============================================================================

      print_header "3. 추가 보안 권장사항"

      # SELinux 상태 확인
      if command -v getenforce >/dev/null 2>&1; then
          selinux_status=$(getenforce 2>/dev/null || echo "Unknown")
          if [ "$selinux_status" = "Enforcing" ]; then
              check_pass "SELinux 강제 모드"
          elif [ "$selinux_status" = "Permissive" ]; then
              check_warn "SELinux 허용 모드 (운영환경에서는 강제 모드 권장)"
          else
              check_warn "SELinux 비활성화 (보안 강화를 위해 활성화 권장)"
          fi
      fi

      # 자동 업데이트 설정 확인
      if grep -q "package_update: true" /etc/cloud/cloud.cfg.d/* 2>/dev/null; then
          check_pass "패키지 자동 업데이트 활성화"
      else
          check_warn "패키지 자동 업데이트 설정 확인 필요"
      fi

      # 시스템 리소스 제한 확인
      if [ "$DOCKER_AVAILABLE" = true ]; then
          if docker inspect secure-ftp-server 2>/dev/null | grep -q "Memory"; then
              check_pass "컨테이너 리소스 제한 고려됨"
          else
              check_warn "컨테이너 메모리/CPU 제한 설정 권장"
          fi
      fi

      # ============================================================================
      # 4. 최종 요약
      # ============================================================================

      print_header "4. 검증 결과 요약"

      pass_count=$(grep -c "\[PASS\]" "$LOG_FILE" 2>/dev/null || echo "0")
      fail_count=$(grep -c "\[FAIL\]" "$LOG_FILE" 2>/dev/null || echo "0")
      warn_count=$(grep -c "\[WARN\]" "$LOG_FILE" 2>/dev/null || echo "0")

      echo ""
      echo "=== 검증 결과 요약 ==="
      echo -e "통과: ${GREEN}$pass_count${NC}개"
      echo -e "실패: ${RED}$fail_count${NC}개"
      echo -e "경고: ${YELLOW}$warn_count${NC}개"
      echo ""

      # 리포트 파일에 요약 추가
      {
          echo ""
          echo "=== 검증 결과 요약 ==="
          echo "통과: $pass_count개"
          echo "실패: $fail_count개"
          echo "경고: $warn_count개"
          echo ""
          echo "=== 상세 결과 ==="
          if [ -f "$LOG_FILE" ]; then
              grep "\[PASS\]\|\[FAIL\]\|\[WARN\]" "$LOG_FILE" 2>/dev/null || echo "로그 파일에서 결과를 읽을 수 없습니다."
          else
              echo "로그 파일이 생성되지 않았습니다."
          fi
      } >> "$REPORT_FILE" 2>/dev/null || echo "리포트 파일에 쓸 수 없습니다."

      # 권장사항 출력
      echo "=== 권장사항 ==="
      if [ "$fail_count" -gt 0 ]; then
          echo "- 실패 항목들을 우선적으로 해결하세요."
      fi
      if [ "$warn_count" -gt 0 ]; then
          echo "- 경고 항목들을 검토하여 보안을 강화하세요."
      fi
      echo "- 정기적으로 보안 검증을 수행하세요."
      echo "- 로그를 모니터링하여 이상 징후를 탐지하세요."
      echo ""

      echo ""
      if [ -f "$REPORT_FILE" ]; then
          echo "상세 리포트가 $REPORT_FILE에 저장되었습니다."
      fi
      if [ -f "$LOG_FILE" ]; then
          echo "로그는 $LOG_FILE에서 확인할 수 있습니다."
      fi

      # 전체 점수 계산
      total_checks=$((pass_count + fail_count + warn_count))
      if [ "$total_checks" -gt 0 ]; then
          score=$((pass_count * 100 / total_checks))
          echo ""
          echo "=== KISA/CSAP 준수도 ==="
          if [ "$score" -ge 90 ]; then
              echo -e "준수도: ${GREEN}$score%${NC} (우수)"
          elif [ "$score" -ge 70 ]; then
              echo -e "준수도: ${YELLOW}$score%${NC} (양호)"
          else
              echo -e "준수도: ${RED}$score%${NC} (개선 필요)"
          fi
      fi

      print_header "KISA/CSAP 기술적취약점평가 체크리스트 검증 완료"

  # 보안 강화 FTP 설정 스크립트 (오류 수정)
  - path: /opt/setup_ftp.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -e

      LOG="/var/log/ftp-setup.log"
      exec > >(tee -a $LOG) 2>&1

      echo "$(date): 보안 FTP 서버 설정 시작"

      # Docker 서비스 준비 대기
      timeout=120
      while [ $timeout -gt 0 ]; do
        if docker info >/dev/null 2>&1; then
          echo "$(date): Docker 준비 완료"
          break
        fi
        sleep 5
        timeout=$((timeout-5))
      done

      if [ $timeout -le 0 ]; then
        echo "$(date): Docker 준비 실패 - 타임아웃"
        exit 1
      fi

      # 보안 디렉토리 구조 생성
      mkdir -p /opt/ftp/{certs,data,config,logs}
      cd /opt/ftp

      # SSL 인증서 생성 (보안 강화)
      openssl req -x509 -nodes -days 365 -newkey rsa:4096 \
        -keyout certs/vsftpd.key \
        -out certs/vsftpd.pem \
        -subj "/C=KR/ST=Seoul/L=Seoul/O=Team2-CSAP/OU=Security/CN=ftpserver.local"

      chmod 600 certs/vsftpd.key
      chmod 644 certs/vsftpd.pem

      # vsftpd 보안 설정 파일 (KISA/CSAP 준수)
      cat > config/vsftpd.conf <<EOF
      # KISA 보안 가이드 준수 설정
      anonymous_enable=NO
      local_enable=YES
      write_enable=NO
      chroot_local_user=YES
      allow_writeable_chroot=YES

      # SSL/TLS 보안 설정 (강화)
      ssl_enable=YES
      rsa_cert_file=/etc/ssl/certs/vsftpd.pem
      rsa_private_key_file=/etc/ssl/private/vsftpd.key
      require_ssl_reuse=NO
      force_local_data_ssl=YES
      force_local_logins_ssl=YES
      ssl_tlsv1_2=YES
      ssl_sslv2=NO
      ssl_sslv3=NO
      ssl_ciphers=HIGH

      # 접근 제어
      userlist_enable=YES
      userlist_file=/etc/vsftpd.user_list
      userlist_deny=NO

      # 로깅 강화
      xferlog_enable=YES
      log_ftp_protocol=YES
      syslog_enable=YES

      # 패시브 모드
      pasv_enable=YES
      pasv_min_port=30000
      pasv_max_port=30010

      # 기타 보안 설정
      listen=YES
      listen_ipv6=NO
      tcp_wrappers=YES
      hide_ids=YES
      ftpd_banner=CSAP Secure FTP Server
      EOF

      # 사용자 허용 목록
      echo "ftpuser" > config/vsftpd.user_list

      # Docker 이미지 빌드 재시도
      for i in {1..3}; do
        if docker pull fauria/vsftpd:latest; then
          echo "$(date): Docker 이미지 다운로드 성공"
          break
        fi
        echo "$(date): Docker 이미지 다운로드 재시도 $i/3"
        sleep 10
      done

      # 공인 IP 조회 (개선된 방법)
      echo "$(date): 공인 IP 조회 중..."
      PUBLIC_IP=$(/opt/get_public_ip.sh)
      if [ $? -eq 0 ]; then
        echo "$(date): 공인 IP 조회 성공: $PUBLIC_IP"
      else
        echo "$(date): 공인 IP 조회 실패, 기본 설정 사용"
        PUBLIC_IP="127.0.0.1"
      fi

      # 기존 컨테이너 정리
      docker stop secure-ftp-server 2>/dev/null || true
      docker rm secure-ftp-server 2>/dev/null || true

      # 보안 강화 컨테이너 실행 (read-only 문제 해결)
      echo "$(date): FTP 컨테이너 실행 중..."
      docker run -d \
        --name secure-ftp-server \
        --restart always \
        -p 21:21 \
        -p 30000-30010:30000-30010 \
        -v /opt/ftp/data:/home/ftpuser \
        -v /opt/ftp/logs:/var/log/vsftpd \
        --security-opt no-new-privileges:true \
        --cap-drop ALL \
        --cap-add CHOWN \
        --cap-add DAC_OVERRIDE \
        --cap-add SETUID \
        --cap-add SETGID \
        --cap-add NET_BIND_SERVICE \
        -e FTP_USER=ftpuser \
        -e FTP_PASS=SecureFTP2024! \
        -e PASV_ADDRESS="$PUBLIC_IP" \
        -e PASV_MIN_PORT=30000 \
        -e PASV_MAX_PORT=30010 \
        -e LOG_STDOUT=YES \
        fauria/vsftpd

      # 컨테이너 상태 확인 (재시도 로직 추가)
      echo "$(date): 컨테이너 시작 대기 중..."
      for i in {1..12}; do
        sleep 5
        if docker ps | grep secure-ftp-server | grep -q "Up"; then
          echo "$(date): FTP 서버 컨테이너 정상 실행 중"
          break
        elif [ $i -eq 12 ]; then
          echo "$(date): FTP 서버 컨테이너 시작 실패"
          docker logs secure-ftp-server || true
          
          # 간단한 설정으로 재시도
          echo "$(date): 간단한 설정으로 재시도"
          docker stop secure-ftp-server 2>/dev/null || true
          docker rm secure-ftp-server 2>/dev/null || true
          
          docker run -d \
            --name secure-ftp-server \
            --restart always \
            -p 21:21 \
            -p 30000-30010:30000-30010 \
            -v /opt/ftp/data:/home/ftpuser \
            -v /opt/ftp/logs:/var/log/vsftpd \
            -e FTP_USER=ftpuser \
            -e FTP_PASS=SecureFTP2024! \
            -e PASV_ADDRESS="$PUBLIC_IP" \
            -e PASV_MIN_PORT=30000 \
            -e PASV_MAX_PORT=30010 \
            -e LOG_STDOUT=YES \
            fauria/vsftpd
            
          sleep 10
          if docker ps | grep secure-ftp-server | grep -q "Up"; then
            echo "$(date): 간단한 설정으로 FTP 서버 실행 성공"
            break
          fi
        else
          echo "$(date): 컨테이너 시작 대기 중... $i/12"
        fi
      done

      # 인증 정보 저장 (공인 IP 반영)
      cat > /opt/ftp/credentials.txt <<EOF
      CSAP 보안 준수 FTP 서버 접속 정보
      ================================
      서버: $PUBLIC_IP
      포트: 21 (FTP)
      사용자: ftpuser
      비밀번호: SecureFTP2024!
      패시브 포트: 30000-30010
      보안: 기본 FTP (SSL/TLS 설정 포함)
      ================================
      생성일: $(date)

      주의사항:
      - FTP 클라이언트에서 패시브 모드 사용
      - 포트 30000-30010이 방화벽에서 허용되어야 함
      - SSL/TLS 지원 클라이언트 사용 권장
      EOF
      chmod 600 /opt/ftp/credentials.txt

      echo "$(date): 보안 FTP 서버 설정 완료"
      echo "$(date): 접속 정보는 /opt/ftp/credentials.txt 파일에서 확인 가능"

# 실행 명령
runcmd:
  # DNS 설정 재적용
  - systemctl restart NetworkManager || true
  - systemctl restart systemd-resolved 2>/dev/null || true

  # SELinux 설정 (보안 정책에 따라)
  - setenforce 0
  - sed -i 's/SELINUX=enforcing/SELINUX=permissive/' /etc/selinux/config

  # 방화벽 설정
  - systemctl enable firewalld
  - systemctl start firewalld
  - firewall-cmd --permanent --add-port=21/tcp
  - firewall-cmd --permanent --add-port=22/tcp
  - firewall-cmd --permanent --add-port=30000-30010/tcp
  - firewall-cmd --reload

  # 1단계: Docker 설치 (순차 실행으로 변경)
  - echo "=== Docker 설치 시작 ===" > /var/log/setup-progress.log
  - /opt/install_docker.sh
  - echo "=== Docker 설치 완료 ===" >> /var/log/setup-progress.log

  # 2단계: FTP 서버 설정 (Docker 설치 완료 후 바로 실행)
  - echo "=== FTP 서버 설정 시작 ===" >> /var/log/setup-progress.log
  - /opt/setup_ftp.sh
  - echo "=== FTP 서버 설정 완료 ===" >> /var/log/setup-progress.log

  # 3단계: 파일 소유권 변경 (사용자 생성 완료 후)
  - chown azureuser:azureuser /home/azureuser/safe_checker.sh 2>/dev/null || echo "safe_checker.sh 소유권 변경 실패" >> /var/log/setup-progress.log
  - chmod +x /home/azureuser/safe_checker.sh 2>/dev/null || echo "safe_checker.sh 권한 변경 실패" >> /var/log/setup-progress.log

  # 4단계: 편의를 위한 별칭과 심볼릭 링크 생성
  - ln -sf /home/azureuser/safe_checker.sh /usr/local/bin/security-check 2>/dev/null || true
  - echo 'alias security-check="sudo /home/azureuser/safe_checker.sh"' >> /home/azureuser/.bashrc 2>/dev/null || true
  - echo 'alias sc="sudo /home/azureuser/safe_checker.sh"' >> /home/azureuser/.bashrc 2>/dev/null || true

  # 5단계: README 파일 생성
  - |
    cat > /home/azureuser/README.md <<'EOF'
    # KISA/CSAP 보안 준수 FTP 서버

    ## 설정 완료 후 사용 가능한 명령어

    ### 보안 검증
    ```bash
    # 전체 보안 체크리스트 검증
    sudo ./safe_checker.sh

    # 또는 별칭 사용
    security-check
    sc
    ```

    ### FTP 서버 관리
    ```bash
    # 컨테이너 상태 확인
    sudo docker ps

    # FTP 서버 로그 확인
    sudo docker logs secure-ftp-server

    # 접속 정보 확인
    sudo cat /opt/ftp/credentials.txt

    # FTP 서버 재시작
    sudo docker restart secure-ftp-server
    ```

    ### 로그 확인
    ```bash
    # 설치 로그
    sudo tail -f /var/log/docker-install.log
    sudo tail -f /var/log/ftp-setup.log

    # 보안 검증 로그
    sudo tail -f /var/log/kisa-csap-check.log

    # 설정 진행 상황
    sudo tail -f /var/log/setup-progress.log
    ```

    ### 주요 파일 위치
    - FTP 설정: /opt/ftp/config/vsftpd.conf
    - SSL 인증서: /opt/ftp/certs/
    - 데이터 디렉토리: /opt/ftp/data/
    - 접속 정보: /opt/ftp/credentials.txt
    - 보안 체커: ~/safe_checker.sh
    EOF

  - chown azureuser:azureuser /home/azureuser/README.md 2>/dev/null || true

  # 6단계: 최종 상태 확인
  - echo "=== 최종 상태 확인 ===" >> /var/log/setup-progress.log
  - docker ps >> /var/log/setup-progress.log 2>&1 || echo "Docker 컨테이너 상태 확인 실패" >> /var/log/setup-progress.log
  - systemctl status docker --no-pager >> /var/log/setup-progress.log 2>&1 || true
  - ls -la /opt/ftp/ >> /var/log/setup-progress.log 2>&1 || echo "/opt/ftp/ 디렉토리 확인 실패" >> /var/log/setup-progress.log
  - echo "=== 설정 완료 ===" >> /var/log/setup-progress.log

# SSH 설정
ssh_pwauth: true
disable_root: false

# 비밀번호 설정 (보안 정책 준수)
chpasswd:
  list: |
    root:SecureRoot2024!
    azureuser:It12345!
  expire: false

# 최종 메시지
final_message: "KISA/CSAP 보안 준수 FTP 서버 설정 완료! 설정 진행 상황: /var/log/setup-progress.log 확인. 완료 후 'sudo ./safe_checker.sh' 또는 'security-check'로 보안 검증 실행 가능. 접속 정보는 /opt/ftp/credentials.txt에서 확인. 상세 사용법은 ~/README.md 참조."
